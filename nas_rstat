#!/PBS/bin/pbs_python
# $Header:$
#Author:dtalcott
#Purpose:Python equivalent of pbs_rstat, but with options for how
#Purpose:to display the output.
#Purpose:Use --help for details.
#Last-modified: $Author: dtalcott $ on $Date: 2020/06/13 12:09:40 $
#Reviewed-by: 
#Reviewed-on: 

import sys
import os
import argparse
import re
import subprocess
import socket
import time

PBS_EXEC = os.environ.get('PBS_EXEC', '/PBS')
sys.path.append(os.path.join(PBS_EXEC, 'lib', 'site'))

import pbs_ifl as ifl
from nas_utils import *
from nas_pbsutil import get_server
import nas_layout as layout
import nas_field_format
from nas_field_format import NAS_field_format,gen_field

long_desc = '''Display information about reservations

This command displays information about PBS reservations. It is similar
to pbs_rstat, but accepts field selections similarly to NAS's qstat.
'''

pbs_conf = ifl.cvar.pbs_conf
verbose = 0
args = None
opts_W = list()

def main():
    global verbose, args, opts_W
    # Don't catch any signals (so no ugly tracebacks on Ctrl-C).
    for i in range(1, 30):
        try:
            signal.signal(i, signal.SIG_DFL)
        except:
            pass
    prog = sys.argv[0].split('/')[-1]
    parser = argparse.ArgumentParser(description=long_desc, prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-B', default=False, action='store_true',
        help='brief output: just reservation IDs')
    parser.add_argument('-F', default=False, action='store_true',
        help='request full details')
    parser.add_argument('-S', default=False, action='store_true',
        help='request short output (default)')
    parser.add_argument('--verbose', '-v', default=0, action='count',
        help='increase debugging verbosity')
    parser.add_argument('--version', action='version',
        version='%(prog)s $Id:$')
    parser.add_argument('-W', action='append', metavar='display option',
        help='options affecting field selection and disply. See qstat.1B')
    parser.add_argument('resvids', nargs=argparse.REMAINDER,
        help='reservations to list')

    args = parser.parse_args()

    default_fields = ['name', 'queue', 'user', 'state', 'start', 'duration', 'end']
    verbose = args.verbose
    levels = 0
    if args.B: levels += 1
    if args.F: levels += 1
    if args.S: levels += 1
    if (levels > 1):
        print("Use only one of B, F, S, f", file=sys.stderr)
        return 1
    # Build list of known fields
    opts_W = args.W
    if opts_W is None:
        opts_W = list()
    if args.B:
        default_fields = ['name']

    if (ifl.pbs_loadconf(0) == 0):
        print("Cannot get PBS configuration information", file=sys.stderr)
        return 1
    # Load possible user or system overrides
    more_code = load_sysexits()
    if more_code:
        prog = compile(more_code, 'sysexit code', 'exec')
        exec(prog, globals(), locals())
    sysexit_post_opts(globals(), locals())
    fmtr = NAS_field_format(default_fields, verbose, opts_W)
    fmtr.known_fields = gen_field_list()
    sysexit_add_fields(globals(), locals())
    # Handle -W options
    (field_list, attr_list, errs) = fmtr.collect_fields()
    if (errs):
        print(errs, file = sys.stderr)
    rc = fmtr.adjust_formats(field_list)
    if rc != True:
        print(rc, file=sys.stderr)
        return 1
    fmtr.field_list = field_list
    if args.F:
        attr_list = None
    # Collect the info
    resvs = get_resv_info(args.resvids, attr_list)
    # Display it
    if args.B:
        display_brief(resvs, fmtr)
    elif args.F:
        display_full(resvs, fmtr)
    else:
        display_standard(resvs, fmtr)
    return 0

def display_brief(resvs, fmtr):
    '''Display brief output.

    That is, display only the reservation IDs
    Args:
        resvs = list of info for reservatons
        fmtr = <ignored>
    '''
    for resv in resvs:
        resvid = resv['id']
        print("Resv ID:", resvid)

def display_full(resvs, fmtr):
    '''Display full output.

    Display everything about the reservations, one line per item.

    Args:
        resvs = list of info for reservations
        fmtr = field formatter object
    '''
    for resv in resvs:
        resvid = resv['id']
        print("Resv ID:", resvid)
        for key in sorted(resv):
            tag = key
            value = resv[key]
            # Skip a few boring items
            if key in ['id', 'resv_nodes', 'interactive']:
                continue
            elif key == 'reserve_state':
                value = fmtr.decode_state_full(value)
            elif key in ['reserve_start', 'reserve_end', 'ctime', 'mtime']:
                value = fmtr.decode_epoch_full(value)
            print(key, '=', value)
        print()

def display_standard(resvs, fmtr):
    '''Output info in standard format

    For each reservation, generate a list of display values for each
    selected field. Collect those lists into a list and pass it to
    layout for display.
    Args:
        resvs = list of info for reservations
        fmtr = field formatter object
    '''
    global opts_W

    c = layout.Config()
    for fld in fmtr.field_list:
        title = fld['title']
        if not title:
            title = fld['name']
        c.add_field(title, **fld['format'])
    rows = list()
    for resv in resvs:
        row = list()
        for f in fmtr.field_list:
            func = getattr(nas_field_format, f['func'])
            row.append(func(f, resv, opts_W))
        rows.append(row)
    if rows:
        show_hdr = '-h' not in opts_W
        res = layout.layout(c, rows, show_hdr=show_hdr)
        print('\n'.join([x.rstrip() for x in res]))

def gen_field_list():
    '''Generate list of known fields

    Returns: list of field_info dicts for known fields
    The dict have these key/value pairs
        name: the name of the field
        format: dict suitable for passing to layout.add_field()
        func: name of function to calculate display value
        sources: reservation attributes whose values are needed by func
    '''
    fl = []
    fl.append(gen_field('name', 'Name', None, 'fmt_by_attr', 'Reserve_Name'))
    fl.append(gen_field('queue', 'Queue', None, 'fmt_by_name', 'queue'))
    fl.append(gen_field('user', 'User', None, 'fmt_user', 'Reserve_Owner'))
    fl.append(gen_field('state', 'State', None, 'fmt_state', 'reserve_state'))
    fl.append(gen_field('start', 'Start', {'hj':'r'}, 'fmt_date', 'reserve_start'))
    fl.append(gen_field('duration', 'Duration', {'hj':'r'}, 'fmt_duration', 'reserve_duration'))
    fl.append(gen_field('end', 'End', None, 'fmt_date', 'reserve_end'))
    fl.append(gen_field('groups', 'Groups', None, 'fmt_by_attr', 'Authorized_Groups'))
    fl.append(gen_field('users', 'Users', None, 'fmt_by_attr', 'Authorized_Users'))
    fl.append(gen_field('nodes', 'Nodes', None, 'fmt_nodes', 'resv_nodes'))
    fl.append(gen_field('reserved', 'Reserved', None, 'fmt_by_attr', 'resv_nodes'))
    fl.append(gen_field('select', 'Select', None, 'fmt_by_name', 'Resource_List'))
    fl.append(gen_field('sselect', 'SSelect', None, 'fmt_by_attr', 'schedselect'))
    fl.append(gen_field('nodect', 'Nodect', {'hj': 'r'}, 'fmt_by_name', 'Resource_List'))
    fl.append(gen_field('model', 'Model', None, 'fmt_model', 'schedselect'))
    fl.append(gen_field('id', 'Resv ID', None, 'fmt_id', None))
    return fl

def get_resv_info(resvids, attr_list):
    '''Ask server for info about reservations

    Args:
        resvids = list of reservation IDs
        attr_list = list of interesting attributes.
    Returns:
        List of PBS batchstatus results
    '''
    bu = BatchUtils()
    if attr_list != None:
        attr_list = (','.join(attr_list)).split(',')
        atl = bu.list_to_attrl(list(attr_list))
    else:
        atl = None
    bs = list()
    if resvids == None or len(resvids) == 0:
        # Ask for all reservations
        conn = ifl.pbs_connect(None)
        if conn < 0:
            print("Cannot connect to PBS server: %s" % ifl.pbs_Errno(),
                file = sys.stderr)
            return None
        bs = ifl.pbs_statresv(conn, None, atl, None)
    else:
        cur_server = None
        conn = None
        for resid in resvids:
            (seq_no, server) = get_server(resid)
            if seq_no == None and server == None:
                print("Invalid request id:", resid, file=sys.stderr)
                continue
            if server == None:
                server = pbs_conf.pbs_server_name
            if server != cur_server:
                if conn != None:
                    ifl.pbs_disconnect(conn)
                    cur_server = None
                conn = ifl.pbs_connect(server)
                if conn < 0:
                    print("Cannot connect to PBS server %s: %s" % \
                        (server, ifl.pbs_Errno()))
                    break
                cur_server = server
            bs1 = ifl.pbs_statresv(conn, seq_no, atl, None)
            if verbose > 1:
                print(bs1)
            bs.extend(bs1)
    if conn != None and conn >= 0:
        ifl.pbs_disconnect(conn)
    if verbose > 1:
        print (bs)
    return bs

def load_sysexits():
    '''Load text of sysexit overrides

    Returns:
        Catenation of all sysexit file contents
    '''
    code = ''
    # Load system sysexit, if present.
    pbs_home = pbs_conf.pbs_home_path
    if pbs_home:
        path = os.path.join(pbs_home, 'lib', 'site', 'rstat_sysexits')
        try:
            if os.stat(path):
                with open(path) as f:
                    code += f.read()
        except FileNotFoundError:
            pass
    # Append any user's sysexit code
    home = os.path.expanduser('~')
    if home != None:
        path = os.path.join(home, '.rstat_sysexits')
        try:
            if os.stat(path):
                with open(path) as f:
                    code += f.read()
        except FileNotFoundError:
            pass
    return code

# Dummy sysexit routines that can be overridden by user/system

def sysexit_post_opts(g, l):
    pass

def sysexit_add_fields(g, l):
    pass

def sysexit_post_statresv(g, l):
    pass

if __name__ == '__main__':
    sys.exit(main())

# vi:ts=4:sw=4:expandtab
