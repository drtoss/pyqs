#!/PBS/bin/pbs_python
# $Header:$
#Author:dtalcott
#Purpose:Python equivalent of pbs_rstat, but with options for how
#Purpose:to display the output.
#Purpose:Use --help for details.
#Last-modified: $Author: dtalcott $ on $Date: 2020/06/13 12:09:40 $
#Reviewed-by: 
#Reviewed-on: 

import sys
import os
import argparse
import re
import subprocess
import socket
import time

PBS_EXEC = os.environ.get('PBS_EXEC', '/PBS')
# sys.path.append('/PBS_new/lib/site')
sys.path.append(os.path.join(PBS_EXEC, 'lib', 'site'))

import pbs_ifl as ifl
from utils import BatchUtils
import nas_layout as layout
import nas_field_format
from nas_field_format import NAS_field_format,gen_field

long_desc = '''Display information about reservations

This command displays information about PBS reservations. It is similar
to pbs_rstat, but accepts field selections similarly to NAS's qstat.
'''

pbs_conf = ifl.cvar.pbs_conf
verbose = 0
args = None
opts_W = list()
default_fields = ['name', 'queue', 'user', 'state', 'start', 'duration', 'end']

def main():
    global verbose, args, opts_W, default_fields
    # Don't catch any signals (so no ugly tracebacks on Ctrl-C).
    for i in range(1, 30):
        try:
            signal.signal(i, signal.SIG_DFL)
        except:
            pass
    prog = sys.argv[0].split('/')[-1]
    parser = argparse.ArgumentParser(description=long_desc, prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-B', default=False, action='store_true',
        help='brief output: just reservation IDs')
    parser.add_argument('-F', default=False, action='store_true',
        help='request full details')
    parser.add_argument('-S', default=False, action='store_true',
        help='request short output (default)')
    parser.add_argument('--verbose', '-v', default=0, action='count',
        help='increase debugging verbosity')
    parser.add_argument('--version', action='version',
        version='%(prog)s $Id:$')
    parser.add_argument('-W', action='append', metavar='display option',
        help='options affecting field selection and disply. See qstat.1B')
    parser.add_argument('resvids', nargs=argparse.REMAINDER,
        help='reservations to list')

    args = parser.parse_args()

    verbose = args.verbose
    levels = 0
    if args.B: levels += 1
    if args.F: levels += 1
    if args.S: levels += 1
    if (levels > 1):
        print("Use only one of B, F, S, f", file=sys.stderr)
        return 1
    # Build list of known fields
    opts_W = args.W
    if opts_W is None:
        opts_W = list()
    if args.B:
        default_fields = ['name']
    fmtr = NAS_field_format(default_fields, verbose, opts_W)
    fmtr.known_fields = gen_field_list()
    # Handle -W options
    (field_list, attr_list) = fmtr.collect_fields()
    if not fmtr.adjust_formats(field_list):
        return 1
    fmtr.field_list = field_list
    if args.F:
        attr_list = None
    # Collect the info
    if (ifl.pbs_loadconf(0) == 0):
        print("Cannot get PBS configuration information", file=sys.stderr)
        return 1
    resvs = get_resv_info(args.resvids, attr_list)
    # Display it
    if args.B:
        display_brief(resvs, fmtr)
    elif args.F:
        display_full(resvs, fmtr)
    else:
        display_standard(resvs, fmtr)
    return 0

def display_brief(resvs, fmtr):
    '''Display brief output.

    That is, display only the reservation IDs
    Args:
        resvs = list of info for reservatons
        fmtr = <ignored>
    '''
    for resv in resvs:
        resvid = resv['id']
        print("Resv ID:", resvid)

def display_full(resvs, fmtr):
    '''Display full output.

    Display everything about the reservations, one line per item.

    Args:
        resvs = list of info for reservations
        fmtr = field formatter object
    '''
    for resv in resvs:
        resvid = resv['id']
        print("Resv ID:", resvid)
        for key in sorted(resv):
            tag = key
            value = resv[key]
            # Skip a few boring items
            if key in ['id', 'resv_nodes', 'interactive']:
                continue
            elif key == 'reserve_state':
                value = fmtr.decode_state_full(value)
            elif key in ['reserve_start', 'reserve_end', 'ctime', 'mtime']:
                value = fmtr.decode_epoch_full(value)
            print(key, '=', value)
        print()

def display_standard(resvs, fmtr):
    '''Output info in standard format

    For each reservation, generate a list of display values for each
    selected field. Collect those lists into a list and pass it to
    layout for display.
    Args:
        resvs = list of info for reservations
        fmtr = field formatter object
    '''
    global opts_W

    c = layout.Config()
    for fld in fmtr.field_list:
        title = fld['title']
        if not title:
            title = fld['name']
        c.add_field(title, **fld['format'])
    rows = list()
    for resv in resvs:
        row = list()
        for f in fmtr.field_list:
            func = getattr(nas_field_format, f['func'])
            row.append(func(f, resv, opts_W))
        rows.append(row)
    if rows:
        show_hdr = '-h' not in opts_W
        res = layout.layout(c, rows, show_hdr=show_hdr)
        print('\n'.join([x.rstrip() for x in res]))

def gen_field_list():
    '''Generate list of known fields

    Returns: list of field_info dicts for known fields
    The dict have these key/value pairs
        name: the name of the field
        format: dict suitable for passing to layout.add_field()
        func: name of function to calculate display value
        sources: reservation attributes whose values are needed by func
    '''
    fl = []
    fl.append(gen_field('name', 'Name', None, 'fmt_by_attr', 'Reserve_Name'))
    fl.append(gen_field('queue', 'Queue', None, 'fmt_by_name', 'queue'))
    fl.append(gen_field('user', 'User', None, 'fmt_user', 'Reserve_Owner'))
    fl.append(gen_field('state', 'State', None, 'fmt_state', 'reserve_state'))
    fl.append(gen_field('start', 'Start', {'hj':'r'}, 'fmt_date', 'reserve_start'))
    fl.append(gen_field('duration', 'Duration', {'hj':'r'}, 'fmt_duration', 'reserve_duration'))
    fl.append(gen_field('end', 'End', None, 'fmt_date', 'reserve_end'))
    fl.append(gen_field('groups', 'Groups', None, 'fmt_by_attr', 'Authorized_Groups'))
    fl.append(gen_field('users', 'Users', None, 'fmt_by_attr', 'Authorized_Users'))
    fl.append(gen_field('nodes', 'Nodes', None, 'fmt_nodes', 'resv_nodes'))
    fl.append(gen_field('reserved', 'Reserved', None, 'fmt_by_attr', 'resv_nodes'))
    fl.append(gen_field('select', 'Select', None, 'fmt_by_name', 'Resource_List'))
    fl.append(gen_field('sselect', 'SSelect', None, 'fmt_by_attr', 'schedselect'))
    fl.append(gen_field('nodect', 'Nodect', {'hj': 'r'}, 'fmt_by_name', 'Resource_List'))
    fl.append(gen_field('id', 'Resv ID', None, 'fmt_id', None))
    return fl

def get_resv_info(resvids, attr_list):
    '''Ask server for info about reservations

    Args:
        resvids = list of reservation IDs
        attr_list = list of interesting attributes.
    Returns:
        List of PBS batchstatus results
    '''
    bu = BatchUtils()
    if attr_list != None:
        attr_list = (','.join(attr_list)).split(',')
        atl = bu.list_to_attrl(list(attr_list))
    else:
        atl = None
    bs = list()
    if resvids == None or len(resvids) == 0:
        # Ask for all reservations
        conn = ifl.pbs_connect(None)
        if conn < 0:
            print("Cannot connect to PBS server: %s" % ifl.pbs_Errno(),
                file = sys.stderr)
            return None
        bs = ifl.pbs_statresv(conn, None, atl, None)
    else:
        cur_server = None
        conn = None
        for resid in resvids:
            (seq_no, server) = get_server(resid)
            if seq_no == None and server == None:
                print("Invalid request id:", resid, file=sys.stderr)
                continue
            if server == None:
                server = pbs_conf.pbs_server_name
            if server != cur_server:
                if conn != None:
                    ifl.pbs_disconnect(conn)
                    cur_server = None
                conn = ifl.pbs_connect(server)
                if conn < 0:
                    print("Cannot connect to PBS server %s: %s" % \
                        (server, ifl.pbs_Errno()))
                    break
                cur_server = server
            bs1 = ifl.pbs_statresv(conn, seq_no, atl, None)
            if verbose > 1:
                print(bs1)
            bs.extend(bs1)
    if conn != None and conn >= 0:
        ifl.pbs_disconnect(conn)
    if verbose > 1:
        print (bs)
    return bs

def get_server(job_id):
    '''Split job ID into its pieces

    Also works for reservations.
    Args:
        job_id = job id in one of its various forms
    Returns:
        (job_id, server) tuple
        job_id will be None on error
    Based on C routine by the same name.
    '''
    job_id = job_id.strip()
    if job_id.startswith('@'):
        return (None, job_id[1:])
    server_out = None
    pbs_server_name = pbs_conf.pbs_server_name
    (seq_num, parent_server, current_server) = parse_jobid(job_id)
    if seq_num == None:
        return (None, None)
    if parent_server and not pbs_server_name:
        pbs_server_name = parent_server
        server_out = parent_server
    if current_server:
        server_out = current_server
    job_id_out = seq_num
    if parent_server:
        if pbs_server_name:
            s = parent_server.lower()
            t = pbs_server_name.lower()
            if s == t:
                job_id_out = job_id_out + '.' + pbs_server_name
                return (job_id_out, server_out)
            try:
                (hname, alias, ipaddr) = socket.gethostbyname_ex(parent_server)
                parent_server = hname
            except:
                pass
            job_id_out = job_id_out + '.' + parent_server
            if not server_out:
                server_out = parent_server
            return (job_id_out, server_out)
    if not pbs_server_name:
        return (None, None)
    job_id_out = job_id_out + '.' + pbs_server_name
    return (job_id_out, server_out)

if __name__ == '__main__':
    sys.exit(main())

# vi:ts=4:sw=4:expandtab
