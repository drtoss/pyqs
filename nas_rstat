#!/usr/bin/python3
# $Header:$
#Author:dtalcott
#Purpose:Python equivalent of pbs_rstat, but with options for how
#Purpose:to display the output.
#Purpose:Use --help for details.
#Last-modified: $Author: dtalcott $ on $Date: 2020/06/13 12:09:40 $
#Reviewed-by: 
#Reviewed-on: 

import sys
import os
import argparse
import re
import subprocess
import socket
import time

PBS_EXEC = os.environ.get('PBS_EXEC', '/PBS')
sys.path.append('/PBS_new/lib/site')
sys.path.append(os.path.join(PBS_EXEC, 'lib', 'site'))

import pbs_ifl as ifl
from utils import BatchUtils
import layout

long_desc = '''Display information about reservations

This command displays information about PBS reservations. It is similar
to pbs_rstat, but accepts field selections similarly to NAS's qstat.
'''

pbs_conf = ifl.cvar.pbs_conf
verbose = 0
args = None
default_fields = ['name', 'queue', 'user', 'state', 'start', 'duration', 'end']
known_fields = []
field_list = []

def main():
    global verbose, args, field_list, known_fields
    # Don't catch any signals (so no ugly tracebacks on Ctrl-C).
    for i in range(1, 30):
        try:
            signal.signal(i, signal.SIG_DFL)
        except:
            pass
    prog = sys.argv[0].split('/')[-1]
    parser = argparse.ArgumentParser(description=long_desc, prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-B', default=False, action='store_true',
        help='brief output: just reservation IDs')
    parser.add_argument('-F', '-f', default=False, action='store_true',
        help='request full details')
    parser.add_argument('-S', default=False, action='store_true',
        help='request short output (default)')
    parser.add_argument('--verbose', '-v', default=0, action='count',
        help='increase debugging verbosity')
    parser.add_argument('--version', action='version',
        version='%(prog)s $Id:$')
    parser.add_argument('-W', action='append',
        help='options affecting field selection and disply. See qstat.1B')
    parser.add_argument('resvids', nargs=argparse.REMAINDER,
        help='reservations to list')

    args = parser.parse_args()

    verbose = args.verbose
    levels = 0
    if args.B: levels += 1
    if args.F: levels += 1
    if args.S: levels += 1
    if (levels > 1):
        print("Use only one of B, F, S, f", file=sys.stderr)
        return 1
    # Build list of known fields
    known_fields = gen_field_list()
    opts_W = args.W
    if opts_W is None:
        opts_W = list()
    # Handle -W options
    (field_list, attr_list) = collect_fields(default_fields, opts_W)
    if not adjust_formats(field_list, opts_W):
        sys.exit(1)
    # Collect the info
    if (ifl.pbs_loadconf(0) == 0):
        print("Cannot get PBS configuration information", file=sys.stderr)
        return 1
    resvs = get_resv_info(args.resvids, attr_list)
    # Display it
    if args.B:
        display_brief(resvs, field_list)
    elif args.F:
        display_full(resvs, field_list)
    else:
        display_standard(resvs, field_list)
    return 0

def adjust_formats(fl, W):
    '''Adjust layout options for fields

    Take a list of field_info dictionaries and modify the layout parameters
    from the -W options. The options we are interested in look like:

    settings ::= [title] option_list [junk]
    title ::= word | quoted_string
    option_list :== option+
    option ::= '-' key value
    key ::= word
    value ::= word | quoted_string
    quoted_string ::= sglQuotedString | dblQuotedString | QuotedString({ })
    junk ::= remainder of line

    We use the pyparsing module to deal with the ugly option syntax

    Args:
        fl = list of field_info data
        W = -W options from command line
    Returns: True if no errors, else False
    '''
    import pyparsing as pp
    quoted_string = pp.sglQuotedString() | pp.dblQuotedString() | \
            pp.QuotedString(quoteChar = '{', endQuoteChar = '}')
    title = pp.Word(pp.alphanums) | quoted_string
    value = pp.Word(pp.alphanums) | quoted_string
    key = pp.Word(pp.alphas)
    option = pp.Suppress('-') + key + value
    option_list = option[...]
    junk = pp.SkipTo(pp.LineEnd())
    settings = pp.Optional(title('title')) + option_list + \
        pp.Optional(junk('junk'))

    errcnt = 0
    for wopt in W:
        if wopt.startswith('o='):
            continue
        # Is it our kind of W option?
        mo = re.match(r'fmt_(\w+)=(.+)', wopt)
        if not mo:
            print("rejecting %s" % wopt, file=sys.stderr)
            continue
        # Do we care about it?
        name = mo.group(1)
        for i in range(len(fl)):
            if fl[i]['name'] == name:
                idx = i
                break
        else:
            continue
        opt_str = mo.group(2)
        opts = settings.parseString(opt_str)
        if opts.junk:
            print("Garbage in format spec %s at %s" % (wopt, opts.junk),
                file = sys.stderr)
            errcnt += 1
            continue
        # Discard empty junk
        if opts[-1] == '':
            opts.pop()
        # XXX Need to merge opts into fl[idx] format stuff.
    if errcnt:
        return False
    return True

def collect_fields(df, W):
    '''Generate list of fields

    Args:
        df = list of names of default fields
        W = list of -W arguments, if any
    Globals:
        known_fields = List of info about known fields
    Returns:
        (fl, aset) where
L           fl = list of field_info dictionaries describing field selected
                for display
            aset = set of PBS attributes holding data for fields in fl
    '''
    global known_fields, verbose
    fl = df
    if W is None:
        W = []
    for opt in W:
        # Only interested in changes to list of fields
        mo = re.match(r'o=([+-]?)(.*)', opt)
        if not mo:
            continue
        plusminus = mo.group(1)
        names = mo.group(2).split(',')
        if plusminus == '':
            fl = [n.strip() for n in names]
        elif plusminus == '-':
            for name in names:
                name = name.strip()
                while name in fl:
                    fl.remove(name)
        else:
            for name in names:
                fl.append(name.strip())
    # Now, validate fields and constuct results
    knownmap = dict([[x['name'], x] for x in known_fields])
    knowns = set(knownmap.keys())
    requested = set(fl)
    unknowns = requested.difference(knowns)
    if unknowns:
        plural = 's' if len(unknowns) > 1 else ''
        print("Unknown field name%s: %s" % (plural, ', '.join(sorted(unknowns))),
            file=sys.stderr)
        print("Known fields are: %s" % ', '.join(sorted(knowns)),
            file=sys.stderr)
    fil = [knownmap[x] for x in fl]
    aset = set(list([x['sources'] for x in fil]))
    if verbose:
        print("Need these attributes: %s" % ', '.join(sorted(aset)))
    return (fil, aset)

def display_standard(resvs, field_list):
    '''Output info in standard format

    For each reservation, generate a list of display values for each
    selected field. Collect those lists into a list and pass it to
    layout for display.
    Args:
        resvs = list of info for reservations
        field_list = desired fields to display
    '''
    c = layout.Config()
    for fld in field_list:
        title = fld['title']
        if not title:
            title = fld['name']
        c.add_field(title, **fld['format'])
    rows = list()
    for resv in resvs:
        row = [globals()[f['func']](f, resv) for f in field_list]
        rows.append(row)
    res = layout.layout(c, rows)
    print('\n'.join(res))

def gen_field_list():
    '''Generate list of known fields

    Returns: list of field_info dicts for known fields
    The dict have these key/value pairs
        name: the name of the field
        format: dict suitable for passing to layout.add_field()
        func: name of function to calculate display value
        sources: reservation attributes whose values are needed by func
    '''
    fl = []
    fl.append(gen_field('name', 'Name', None, 'get_by_attr', 'Reserve_Name'))
    fl.append(gen_field('queue', 'Queue', None, 'get_by_name', 'queue'))
    fl.append(gen_field('user', 'User', None, 'get_by_attr', 'Reserve_Owner'))
    fl.append(gen_field('state', 'State', None, 'get_by_attr', 'reserve_state'))
    fl.append(gen_field('start', 'Start', {'hj':'r'}, 'get_date', 'reserve_start'))
    fl.append(gen_field('duration', 'Duration', {'hj':'r'}, 'get_duration', 'reserve_duration'))
    fl.append(gen_field('end', 'End', None, 'get_date', 'reserve_end'))
    fl.append(gen_field('groups', 'Groups', None, 'get_by_attr', 'Authorized_Groups'))
    fl.append(gen_field('users', 'Users', None, 'get_by_attr', 'Authorized_Users'))
    fl.append(gen_field('nodes', 'Nodes', None, 'get_by_attr', 'resv_nodes'))
    return fl

def gen_field(name, title, form, func, source):
    '''Create a field_info dict

    Args:
        name = name of field
        title = display title for field
        form = dictionary of non-default formatting options for field
        func = name of function to calculate display value of field
        source = PBS attributes used to by func
    '''
    if form is None:
        form = {}
    if func is None:
        func = 'get_by_name'
    if source is None:
        source = ''
    fi = {'name': name,
        'title': title,
        'format': form,
        'func': func,
        'sources': source
        }
    return fi

def get_resv_info(resvids, attr_list):
    '''Ask server for info about reservations

    Args:
        resvids = list of reservation IDs
        attr_list = list of interesting attributes.
    Returns:
        List of PBS batchstatus results
    '''
    bu = BatchUtils()
    attr_list = (','.join(attr_list)).split(',')
    atl = bu.list_to_attrl(list(attr_list))
    bs = list()
    if resvids == None or len(resvids) == 0:
        # Ask for all reservations
        conn = ifl.pbs_connect(None)
        if conn < 0:
            print("Cannot connect to PBS server: %s" % ifl.pbs_Errno(),
                file = sys.stderr)
            return None
        bs = ifl.pbs_statresv(conn, None, atl, None)
    else:
        cur_server = None
        conn = None
        for resid in resvids:
            (seq_no, server) = get_server(resid)
            if seq_no == None:
                print("Invalid request id:", resid, file=sys.stderr)
                continue
            if server == None:
                server = pbs_conf.pbs_server_name
            if server != cur_server:
                if conn != None:
                    ifl.pbs_disconnect(conn)
                    cur_server = None
                conn = ifl.pbs_connect(server)
                if conn < 0:
                    print("Cannot connect to PBS server %s: %s" % \
                        (server, ifl.pbs_Errno()))
                    break
                cur_server = server
            bs1 = ifl.pbs_statresv(conn, seq_no, atl, None)
            if verbose > 1:
                print(bs1)
            bs.extend(bs1)
    ifl.pbs_disconnect(conn)
    if verbose > 1:
        print (bs)
    return bs

def get_server(job_id):
    '''Split job ID into its pieces

    Also works for reservations.
    Args:
        job_id = job id in one of its various forms
    Returns:
        (job_id, server) tuple
        job_id will be None on error
    Based on C routine by the same name.
    '''
    job_id = job_id.strip()
    if job_id.startswith('@'):
        return (None, job_id[1:])
    server_out = None
    pbs_server_name = pbs_conf.pbs_server_name
    (seq_num, parent_server, current_server) = parse_jobid(job_id)
    if seq_num == None:
        return (None, None)
    if current_server:
        server_out = current_server
    job_id_out = seq_num
    if parent_server:
        if pbs_server_name:
            s = parent_server.lower()
            t = pbs_server_name.lower()
            if s == t:
                job_id_out = job_id_out + '.' + pbs_server_name
                return (job_id_out, server_out)
            try:
                (hname, alias, ipaddr) = socket.gethostbyname_ex(parent_server)
                parent_server = hname
            except:
                pass
            job_id_out = job_id_out + '.' + parent_server
            if not server_out:
                server_out = parent_server
            return (job_id_out, server_out)
    if not pbs_server_name:
        return (None, None)
    job_id_out = job_id_out + '.' + pbs_server_name
    return (job_id_out, server_out)

# Functions to compute specific values for display
# get_xxx(fi, rinfo)
# Args:
#   fi = field info
#   rinfo = reservation info

def get_by_attr(fi, rinfo):
    attr_name = fi['sources']
    return get_by_name(fi, rinfo, attr_name)

def get_by_name(fi, rinfo, name=None):
    if name == None:
        name = fi['name']
    if name in rinfo:
        result = rinfo[name]
    else:
        t = 'Resource_List.' + name
        if t in rinfo:
            result = rinfo[t]
        else:
            result = '--'
    return result

def get_date(fi, rinfo):
    # XXX
    return get_by_attr(fi, rinfo)

def get_duration(fi, rinfo):
    # XXX
    return get_by_attr(fi, rinfo)

def get_name(fi, rinfo):
    return rinfo['Reserve_Name']

def parse_jobid(job_id):
    '''Split job ID into its pieces

    Also works for reservations.
    Args:
        job_id = job id in one of its various forms
    Returns:
        (seq_num, parent_server, current_server) where
            seq_num = numeric part of job id
            parent_server = hostname where job submitted
            current_server = server currently holding job
    Based on C routine of the same name
    '''
    job_re = r'(?P<seq_no>\d+(\[\d*\])?)(\.(?P<parent>[^@]*))?(@(?P<current>.+))?'
    resv_re = r'(?P<seq_no>[MRS]\d+)(\.(?P<parent>[^@]*))?(@(?P<current>.+))?'
    job_id = job_id.strip()
    if job_id[0].isdigit():
        mo = re.match(job_re, job_id)
        if not mo:
            return (None, None, None)
        seq_no = mo.group('seq_no')
        parent = mo.group('parent')
        current = mo.group('current')
        return (seq_no, parent, current)
    mo = re.match(resv_re, job_id)
    if not mo:
        return (None, None, None)
    seq_no = mo.group('seq_no')
    parent = mo.group('parent')
    current = mo.group('current')
    return (seq_no, parent, current)

if __name__ == '__main__':
    sys.exit(main())

# vi:ts=4:sw=4:expandtab
